---
title: '算法效率评估'
date: '2024-05-15'
tags: ['algorithm']
draft: false
summary: ''
images: ['']
---

# 算法效率评估

在算法设计中, 先后追求下面两个层面的目标:

- **找到问题解法**: 算法需要在规定的输入范围内可靠地求得问题的正确解
- **寻求最优解法**: 同一个问题可能存在多种解法, 希望找到尽可能高效的算法

也就是说, 在能够解决问题的前提下, 算法效率已成为衡量算法优劣的主要评价指标, 包括两个维度:

- **时间效率**: 算法运行速度的快慢
- **空间效率**: 算法占用内存空间的大小

简而言之, **目标是设计 "既快又省" 的数据结构与算法**

而有效地评估算法效率至关重要, 只有这样, 才可以对各种算法进行对比, 进而指导算法设计与优化过程

效率评估方法主要分为两种: **实际测试**, **理论估计**

## 实际测试

假设有算法 A 和算法 B, 都能解决同一问题, 现在需要对比这两个算法的效率. 最直接的方法是运行并记录它们的运行时间和内存分配情况. 这种方式可以反映真实情况但也存在较大的局限性

一方面, **难以排除测试环境的干扰因素**. 硬件配置会影响算法的性能

另一方面, **展开完整测试非常耗费资源**. 随着输入数据量的变化, 算法会表现出不同的效率. 为了得到有说服力的结论, 需要各种规模的输入数据, 而这需要耗费大量的计算资源

## 理论估算

由于实际测试具有较大的局限性, 因此可以考虑仅通过一些计算来评估算法的效率. 这种估算方法被称为**_渐进复杂度分析 (asymptotic complexity analysis)_**, 简称 **_复杂度分析_**

复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系. **它描述了随着输入数据大小的增加, 算法执行所需时间和空间的增长趋势**. 可以将其分为三个重点来解释:

- "时间和空间资源" 分别对应**_时间复杂度 (time complexity)_** 和 **_空间复杂度 (space complexity)_**
- "随着输入数据大小的增加" 意味着复杂度反映了算法运行效率与输入数据体量之间的关系
- "时间和空间的增长趋势" 表示复杂度分析关注的不是运行时间或占用空间的具体值, 而是时间或空间增长的 "快慢"

**复杂度分析克服了实际测试方法的弊端**, 体现在以下两个方面:

- 独立于测试环境, 分析结果适用于所有运行平台
- 可以体现不同数据量下的算法效率, 尤其是在大数据量下的算法性能

复杂度分析提供了算法效率的 "标尺", 可以衡量执行某个算法所需的时间和空间资源, 对比不同算法之间的效率

复杂度是个数学概念, 在深入学习数据结构与算法之前, **先对复杂度分析建立初步的了解, 以便能够完成简单算法的复杂度分析**

---

**如何理解复杂度分析**:

- **基本操作计数**: 确定算法中的基本操作 (比较, 赋值等) 的次数
- **最坏情况分析**: 通常关注最坏情况下的表现, 以保证在所有情况下算法都能正常运行
- **忽略常数和低次项**: 在大 O 表示法中, 常数和低次项通常被忽略, 因为它们对大规模输入的影响比较小
- **渐进分析**: 关注输入规模趋向无穷大时的行为

**例子: 冒泡排序算法的时间复杂度分析**:

冒泡排序是一种简单的排序算法. 它重复遍历要排序的列表, 依次比较每对相邻的元素, 如果元素的顺序错误就交换. 这个过程会重复进行, 直到没有元素需要交换为止

```js
function bubbleSort(arr) {
  let n = arr.length
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = temp
      }
    }
  }

  return arr
}
```

时间复杂度分析:

1. 外层循环: 运行 `n` 次
2. 内层循环: 第一次运行 `n - 1` 次, 第二次运行 `n - 2` 次, 依次类推, 最后运行一次

内层循环总运行次数为: `(n - 1) + (n - 2) + ... + 1 = n(n-1) / 2` 次

因此, 冒泡排序的总操作次数为 `T(n) = n(n-1) / 2`

使用大 O 表示法时, 忽略常数和低次项, 所以 `T(n) ≈ O(n²)`

空间复杂度分析:

冒泡排序使用常量级的额外空间 (只用了几个变量来交换元素和进行循环计数), 因此空间复杂度是 `O(1)`
