---
title: 'Docker 是什么? 和 k8s 是什么关系?'
date: '2024-04-16'
tags: ['docker', 'k8s']
draft: false
summary: '文章将介绍 docker 相关的基础只是及其架构原理以及工作方式, 同时与 k8s 进行比较, 以便更好地理解它们之间的关系'
images: ['https://cdn.jsdelivr.net/gh/Viskeyy/uPic@master/uPic/0416-coverImg_169_2024416174435.png']
---

# Docker 是什么? 和 Kubernetes (k8s) 是什么关系?

作为一个程序员, 如果想要安装一个 **vim** 编辑文本, 在不同的环境中需要执行不同的命令:

- **ubuntu**: `apt-get install vim`
- **centOS**: `yum install vim`

只是装一个 **vim **编辑器就如此麻烦. 如果要将自己的代码部署到各个不同操作系统的服务器上, 所依赖的软件和配置只会更多, 需要针对每个环境单独写一套部署脚本.

这时, 可以通过在代码应用和环境之间添加一层中间层来解决这个问题. 这个中间层就是 **Docker**, 准确来说是 **_Docker 容器_**.

## Docker 是什么?

程序是运行在**操作系统**上的, 而**操作系统**上又有不同的**依赖库**和**配置**, 这种被程序所依赖的, 统称为环境 (操作系统, 依赖库和配置).

程序依赖**环境**, **环境**不同, 程序可能就会出错. 如果将环境和程序一起打包, 给到对方运行, 这样问题就可以解决.

**Docker** 就是这样一款可以将**程序**和**环境**打包并运行的工具软件.

### 基础镜像是什么?

环境不同会导致程序运行结果不同, 首先要做的就是统一环境.

环境中最重要的就是操作系统, 例如是 `centOS` 还是 `ubuntu`, 让程序运行在同一个操作系统上.

操作系统分为**用户空间**和**内核空间**, 应用程序运行在用户空间, 因此可以只保留操作系统的用户空间部分, 就能构建出应用所需的环境.

将选中的操作系统的文件系统和依赖库等 (也就是用户空间), 打包成一个类似压缩包的文件, 这就是所谓的基础镜像 (base image).

### `dockerfile` 是什么?

有了基础镜像还不够, 还需要安装依赖. 比如 `gcc`, 甚至还要创建一些文件夹, 最后才是运行应用.

在 Linux 中, 所有的操作都可以通过命令行完成, 所以可以将要进行的操作以命令行的形式一行一行列出来. 这样一份列清楚了从操作系统到应用服务启动需要做哪些事情的清单文件, 就是所谓的 dockerfile.

### 容器镜像是什么?

`dockerfile` 只是描述了要做哪些操作, 并没有真正开始做. 当用命令行执行 `docker build` 的时候, `docker` 就会按照 `dockerfile` 的说明一行行构建环境和应用. 最终将这个环境和应用打包成一个类似压缩包的东西, 这就是容器镜像 (`Container`).

只要将容器镜像传到任意一台服务器上, 对其进行解压缩, 就能同时运行环境和应用.

但是如何将容器镜像传到所有服务器上?

### Registry 是什么?

服务器很多, 将容器一个一个传到服务器耗时耗力, 并且将所有压力都给到了发送方的网络带宽上.

可以参考 GitHub 代码仓库的做法, 使用 `git push` 将代码传到 GitHub. 有需要的人自己通过 `git pull` 获取代码.

Docker 也一样, 设置一个镜像仓库, 通过 `docker push` 将镜像推送到仓库, 有需要时再通过 `docker pull` 将镜像拉到机器上.

这个负责管理镜像仓库的服务, 就是 `docker registry`.

基于 `docker registry` 的能力, 可以搭建各种官方或私人镜像库, 比如官方的 `dockerhub`, 非官方的清华大学的 `Tuna` 等, 一般公司内部也会有自己的镜像仓库.

### 容器是什么?

在解决了服务器间传输容器镜像的问题之后, 可以在目的服务器上执行 `docker pull` 获取到容器镜像. 然后执行 `docker run` 命令将这个类似压缩包的容器镜像解压缩, 获得一个独立环境和应用程序并运行. 这样一个独立的环境和应用就是所谓的容器 (`container`).

可以在一个操作系统上同时运行多个容器, 且这些容器之间都是相互独立的.

### 容器和虚拟机的关系

传统虚拟机自带一个完整操作系统, 容器本身不带完整的操作系统.

容器内只包含了操作系统的核心依赖库和配置文件等必要组件, 它利用了一个叫 `namespace` 的能力让其看起来就像是一个独立的操作系统. 再利用一个叫 `Cgroup` 的能力, 限制其能使用的计算资源. 容器本质上只是一个自带独立运行环境的特殊进程. 底层用的其实是宿主机的操作系统内核.

## docker 的架构原理

在日常使用场景中, 它是经典的 `client-server` 架构, `client` 对应 `docker-cli`, `server` 对应 `docker daemon`.

在命令行中输入 `docker` 命令, 使用的是 `docker-cli`, 它会解析输入的 command 命令, 然后调用 `docker daemon` 守护进行提供的 `restful API`, 守护进程收到命令后, 会根据命令行创建和管理各个容器.

再具体一些, `docker daemon` 内部分为 `docker server` 和 `Engine` 两层.

- `docker server` 本质上就是一个 HTTP 服务器, 负责对外提供操作容器和镜像的 API 接口. 接收到 API 请求后, 会分发任务给 Engine 层.
- `Engine` 负责创建 job, 由 job 实际执行各种工作. 不同的 docker 命令会执行不同类型的 job 任务.

### docker build

如果执行的是 `docker build` 命令, job 则会根据 `dockerfile` 指令一层层构建容器镜像文件.

### docker pull/push

如果执行的是 `docker pull` 或 `docker push` 之类的镜像推拉操作, job 就会跟外部的 `docker registry` 交互. 将镜像上传或下载.

### docker run

job 会基于镜像文件调用 `containerd` 组件驱使 `runC` 组件创建和运行容器.

## docker compose 是什么

docker 容器本身只是一个特殊进程, 但如果想要部署多个容器, 且对这些容器的顺序有一定的要求, 应该怎样实现.

例如一个博客系统, 先是启动数据库, 再启动身份验证服务, 最后才能启动博客的 web 服务. 挨个执行 docker run 也可以正常运行.

但也可以通过一个 `yaml` 文件写清楚要部署的容器有哪些, 部署顺序是什么, 以及这些容器占用的 CPU 和内存等信息. 然后通过一行 `docker-compose up` 命令开始解析 `yaml` 文件, 将容器意见按顺序部署, 就完成一整套服务的部署. 这就是 `docker compose` 做的事情.

## docker swarm 是什么

docker 解决的是一个容器的部署, `docker compose` 解决的是多个容器组成的一整套服务的部署, `docker swarm` 解决的是一整套服务在多台服务器上的集群部署问题.

例如, 如果某应用在 a 服务器出现问题, 就将该应用在 b 服务器上重新部署一套实现迁移, 还能根据需要对应用做扩缩容.

## docker 和 k8s 的关系

k8s 会在多台 node 的服务器上调度 pod 进行部署和扩缩容, 每个 pod 内部可以含有多个 container, 每个 container 本质上就是一个服务进程.

docker swarm 就是 k8s 的竞品.

docker 部署的容器其实就是 k8s 调用的 pod 里的 container. docker compose 基于多个 container 创建一整套服务, 其实就是 k8s 里的 pod. docker swarm 所做的事情和 k8s 一样, 本质上就是在调度 pod.

再看 k8s 的官方定义叫容器编排引擎, 可以将它理解为以 API 编程的方式管理安排各个容器的引擎.

## 总结

Docker 是一个开源的应用容器引擎, 它允许开发者打包他们的应用以及依赖包到一个可移植的容器中, 然后发布到任何流行的 Linux 机器上, 也可以实现虚拟化. 容器是完全使用沙箱机制, 相互之间不会有任何接口 (类似 iPhone 的 app).

以下是对 Docker 中的一些关键概念的解释：

1. **基础镜像 (Base Image) **: 基础镜像是构建其他高级镜像的基础, 它通常是一个最小化的系统, 包含了运行应用所需的最基本的程序, 库或者工具. 例如, 一个基于 Ubuntu 的基础镜像只包含了 Ubuntu 操作系统的最基本组件.
2. **Dockerfile**: Dockerfile 是一个文本文件, 包含了用户可以用来创建镜像的命令. 通过 Dockerfile, Docker 可以自动化执行这些命令, 构建出新的镜像. 这个文件可以定义操作系统配置, 用户所需的程序及其依赖等.
3. **容器镜像 (Container Image) **: 容器镜像是一个轻量级, 可执行的独立软件包, 包括运行应用所需的所有内容：代码, 运行时, 库, 环境变量和配置文件. 容器镜像在构建时将应用及其全部依赖打包, 确保应用在任何环境中都能一致地运行.
4. **Registry**: Registry 是 Docker 镜像的存储和分发系统, 类似于代码仓库. 用户可以从 Registry 中拉取镜像到本地使用, 也可以将本地的镜像推送到 Registry 中供他人使用. Docker 官方的公共 Registry 是 Docker Hub.
5. **容器 (Container) **: 容器是镜像的运行实例. 当你从镜像启动时, 你启动的是一个容器. 容器是独立运行的, 包含其运行所需的环境配置和依赖, 但是运行在同一操作系统内核上, 不需要额外的操作系统.
6. **架构原理**: Docker 使用客户端-服务器 (C/S) 架构模式. Docker 客户端与 Docker 守护进程通信, Docker 守护进程负责构建, 运行和分发 Docker 容器. Docker 守护进程通过 Docker API 接收来自客户端的指令.

这些组件共同工作, 使得 Docker 能够打包, 分发和运行应用, 提供一种简单, 高效的方式来隔离应用与基础设施.
